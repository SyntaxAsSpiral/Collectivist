#!/usr/bin/env python3
"""
<%= className %> Plugin
<%= description %>
"""

import subprocess
from pathlib import Path
from typing import List, Dict, Any
from datetime import datetime
import sys
import os

# Add parent directory to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent / '.collection'))

from plugin_interface import CollectionScanner, CollectionItem, PluginRegistry


class <%= className %>(CollectionScanner):
    """Scanner for <%= description.toLowerCase() %>"""

    def get_name(self) -> str:
        return "<%= name %>"

    def get_supported_types(self) -> List[str]:
        return [<%= supportedTypes.split(',').map(t => `"${t.trim()}"`).join(', ') %>]

    def get_categories(self) -> List[str]:
        return [
            <%= categories.split(',').map(c => `'${c.trim()}'`).join(',\n            ') %>
        ]

    def detect(self, path: Path) -> bool:
        """
        Detect if this path contains <%= name %>.
        TODO: Implement detection logic for <%= name %> collections
        """
        if not path.is_dir():
            return False

        # TODO: Add specific detection logic
        # Example: check for specific files, directory structure, etc.
        return False

    def scan(self, root_path: Path, config: Dict[str, Any]) -> List[CollectionItem]:
        """
        Scan <%= name %> collection.

        Config options:
        - exclude_hidden: bool (default True) - exclude directories starting with '.'
        - preserve_data: dict - existing descriptions/categories to preserve
        """
        exclude_hidden = config.get('exclude_hidden', True)
        preserve_data = config.get('preserve_data', {})

        items = []

        # TODO: Implement scanning logic
        # Get items based on collection type
        # subdirs = [d for d in root_path.iterdir() if d.is_dir()]

        # Filter hidden if configured
        # if exclude_hidden:
        #     subdirs = [d for d in subdirs if not d.name.startswith('.')]

        # for item_dir in subdirs:
        #     # Get filesystem metadata
        #     stat = item_dir.stat()

        #     # Preserve existing description/category if available
        #     existing = preserve_data.get(str(item_dir), {})

        #     # Create item
        #     item = CollectionItem(
        #         short_name=item_dir.name,
        #         type="dir",
        #         size=stat.st_size,
        #         created=datetime.fromtimestamp(stat.st_ctime).isoformat(),
        #         modified=datetime.fromtimestamp(stat.st_mtime).isoformat(),
        #         accessed=datetime.fromtimestamp(stat.st_atime).isoformat(),
        #         path=str(item_dir),
        #         description=existing.get('description'),
        #         category=existing.get('category'),
        #         metadata={}
        #     )

        #     items.append(item)

        # Sort items (customize as needed)
        # items.sort(key=lambda x: x.size, reverse=True)

        return items

    def get_description_prompt_template(self) -> str:
        return """You are a technical documentation assistant. Generate a one-sentence description and category for a <%= name %> item based on its content.

Available categories (choose ONE):
<% categories.split(',').forEach(cat => { -%>
- <%= cat.trim() %>: Description of <%= cat.trim() %> category
<% }); %>

Content:
---
{content}
---

Generate a JSON response with:
1. "description": A single-sentence description (max 150 characters) that captures the item's core purpose. Be concise and technical.
2. "category": ONE category from the list above that best matches this item.

Example format:
{"description": "Advanced <%= name %> tool for content management", "category": "<%= categories.split(',')[0].trim() %>"}

JSON Response:"""

    def get_example_descriptions(self) -> List[str]:
        return [
            # TODO: Add example descriptions for <%= name %> items
            "Example <%= name %> item description one",
            "Example <%= name %> item description two",
            "Example <%= name %> item description three"
        ]

    def get_content_for_description(self, item: CollectionItem) -> str:
        """
        Extract content for LLM description generation.
        TODO: Customize based on <%= name %> content type
        """
        item_path = Path(item.path)

        # TODO: Look for relevant content files (README, docs, etc.)
        content_patterns = ['README.md', 'readme.md', 'DESCRIPTION', 'description.txt']

        for pattern in content_patterns:
            content_path = item_path / pattern
            if content_path.exists():
                try:
                    with open(content_path, 'r', encoding='utf-8', errors='ignore') as f:
                        return f.read()[:3000]
                except Exception:
                    continue

        # Fallback: return item name or empty string
        return item.short_name


# Register plugin on import
PluginRegistry.register(
    name="<%= name %>",
    scanner_class=<%= className %>,
    version="1.0.0",
    description="<%= description %>"
)